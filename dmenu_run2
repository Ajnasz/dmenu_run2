#!/usr/bin/env sh

# Copyright 2025 Lajos Koszti <lajos@koszti.hu> https://ajnasz.hu
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the “Software”), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

# This script extends the functionality of dmenu_run by allowing the user to
# include custom commands and executables. The custom commands are read from a
# file specified by the environment variable DMENU_RUN_COMMANDS, and the
# executables are read from a directory specified by the environment variable
# DMENU_RUN_BIN.
#
# Environment Variables:
#   DMENU_RUN_COMMANDS: Path to a file containing custom commands to be included
#                       in the dmenu.
#                       Each line can be a regular command or an alias
#
#   DMENU_RUN_BIN: Path to a directory containing executables.
#                  The executables should echo the commands to be included in
#                  the dmenu.
#                  If executable should print a command or an alias.
#
# Usage:
#   Set the environment variables DMENU_RUN_COMMANDS and DMENU_RUN_BIN to point
#   to your custom commands file and executables directory, respectively. Then,
#   run the script. The script will add the custom commands and executables to
#   the dmenu.
#
#   Example:
#     DMENU_RUN_COMMANDS=/path/to/commands.txt DMENU_RUN_BIN=/path/to/bin \
#     ./dmenu_run2
#
# Aliases:
#  If you want to include aliases in the dmenu, you can define them in the following
#  forrmat:
#    alias name="command --with-args"
#    alias name with spaces="command2"
#   The script will extract the alias name and command from the alias definition
#   and include them in the dmenu.
#
# Note:
#   The script assumes that all files in the DMENU_RUN_BIN directory are
#   executable and that they will echo the correct commands. Ensure that these
#   conditions are met to avoid unexpected behavior.
#
#   The script runs in the background, and the selected command from the dmenu
#   is executed in a subshell.
#
# FZF environment variable:
#   The script sets the FZF environment variable to the original dmenu command
#   This allows you to open dmenu with the same options as the original dmenu_run2
#   example script to search for words in the dictionary with dmenu or fzf:
#     > cat /usr/local/bin/words
#     #/usr/bin/env sh
#
#     fuzzy_find="${FZF:-fzf}"
#     $fuzzy_find < /usr/share/dict/words
#
#   If the `words` script called from dmenu_run2 the use dmenu to select a word
#   otherwise it will use `fzf`

# Function to extract alias name from alias definition
extract_alias_name() {
  printf '%s\n' "$1" | sed 's/^alias \([^=]*\)=.*/\1/'
}

# Function to extract alias command from alias definition
extract_alias_command() {
  printf '%s\n' "$1" | sed 's/^alias [^=]*=//' | sed 's/^"\(.*\)"$/\1/'
}

# shellcheck disable=SC2317  # Don't warn about unreachable commands in this function
cleanup() {
  rm -f "$DMENU_FIFO" "$DMENU_ALL_COMMANDS"
}

# Function to process commands and aliases
process_custom_commands() {
  while IFS= read -r line || [ -n "$line" ]; do
    # Skip comments and empty lines
    case "$line" in
      \#*|'') continue ;;
      alias\ *=*)
        # Extract and display alias name only
        extract_alias_name "$line"
        ;;
      *)
        # Regular command
        printf '%s\n' "$line"
        ;;
    esac
  done
}

# Function to resolve alias to its command
# shellcheck disable=SC2317  # Don't warn about unreachable commands in this function
resolve_alias() {
  while IFS= read -r selected || [ -n "$selected" ]; do
    # read $DMENU_RUN_COMMANDS and resolve aliases
    while IFS= read -r line || [ -n "$line" ]; do
      case "$line" in
        alias\ *=*)
          alias_name=$(extract_alias_name "$line")
          if [ "$selected" = "$alias_name" ]; then
            alias_command=$(extract_alias_command "$line")
            # If selected item is an alias, print its command
            printf '%s\n' "$alias_command"
            break
          fi
          ;;
        *)
          # If selected item is a regular command, print it as is
          if [ "$selected" = "$line" ]; then
            printf '%s\n' "$line"
            break
          fi
          ;;
      esac
    done < "$DMENU_ALL_COMMANDS"
  done
}

if [ -z "$DMENU_RUN_BIN" ] || [ ! -d "$DMENU_RUN_BIN" ];then
  echo "Warning: DMENU_RUN_BIN is not set or is not a directory" >&2
fi

if [ -z "$DMENU_RUN_COMMANDS" ] || [ ! -f "$DMENU_RUN_COMMANDS" ];then
  echo "Warning: DMENU_RUN_COMMANDS is not set or is not a file" >&2
fi

DMENU="${DMENU:-dmenu}"
# DMENU="rofi -dmenu -i -no-fixed-num-lines -no-show-icons"
if [ -n "$WAYLAND_DISPLAY" ]; then
  DMENU="bemenu"
fi

# Create FIFO for streaming to dmenu
DMENU_FIFO="$(mktemp -u -t dmenu_fifo_XXXXXX)"
mkfifo "$DMENU_FIFO"

# Create temp file for alias resolution (still needed)
DMENU_ALL_COMMANDS="$(mktemp -t dmenu_run2_XXXXXX)"

trap cleanup EXIT INT TERM

# Populate both FIFO and temp file simultaneously
{
  # include output of executables from DMENU_RUN_BIN
  if [ -n "$DMENU_RUN_BIN" ] && [ -d "$DMENU_RUN_BIN" ]; then
    find "$DMENU_RUN_BIN" -maxdepth 1 -type f -executable -exec {} \;
  fi

  # include custom commands from DMENU_RUN_COMMANDS
  if [ -n "$DMENU_RUN_COMMANDS" ] && [ -f "$DMENU_RUN_COMMANDS" ]; then
      cat "$DMENU_RUN_COMMANDS"
  fi

  # always include dmenu_path
  if [ "$DMENU_NO_PATH" != "true" ]; then
    dmenu_path;
  fi
} | tee "$DMENU_ALL_COMMANDS" > "$DMENU_FIFO" &
TEES_PID=$!

# Process and execute
if process_custom_commands < "$DMENU_FIFO" | $DMENU "$@" | resolve_alias | env FZF="$DMENU $*" "${SHELL:-"/usr/bin/env sh"}" &
then
DMENU_PID=$!
else
    echo "Failed to start dmenu process" >&2
    kill $TEES_PID 2>/dev/null
    exit 1
fi

wait $TEES_PID
TEE_EXIT=$?
if [ $TEE_EXIT -ne 0 ]; then
    echo "Warning: Data population process failed" >&2
fi

wait $DMENU_PID
DMENU_EXIT=$?
# Don't cleanup here since trap will handle it
exit $DMENU_EXIT
